<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Trick | ZSC | ZCR Shellcoder]]></title>
  <link href="http://zsc.z3r0d4y.com/blog/categories/trick/atom.xml" rel="self"/>
  <link href="http://zsc.z3r0d4y.com/"/>
  <updated>2015-08-01T16:55:00+04:30</updated>
  <id>http://zsc.z3r0d4y.com/</id>
  <author>
    <name><![CDATA[Ali Razmjoo]]></name>
    <email><![CDATA[Ali[at]Z3r0D4y[dot]Com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Generate PE File With ZSC Shellcodes]]></title>
    <link href="http://zsc.z3r0d4y.com/blog/2015/08/01/generate-pe-file-with-zsc-shellcodes/"/>
    <updated>2015-08-01T15:10:18+04:30</updated>
    <id>http://zsc.z3r0d4y.com/blog/2015/08/01/generate-pe-file-with-zsc-shellcodes</id>
    <content type="html"><![CDATA[<p>As We know, Shellcodes have much different usages, such as Exploit and Malwares development process, and etc. But there is a question, Could we compile the Shellcodes [Assembly Codes] and run them without inject inside an other process or file? Of course! Shellcodes are bunch of assembly codes with removed null codes or make it injectable in to a process.<br><br>
<strong>ZSC</strong> let us to have disassembly codes inside generated file. It could be used for compiling a sing file.
Take a look at a shellcode which generated by <strong>ZSC</strong>.
<br><br>
```C</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>/*
This shellcode generated by ZCR Shellcoder [zsc] <a href="http://zsc.z3r0d4y.com/">http://zsc.z3r0d4y.com/</a>
Title: system(&lsquo;nc[space]-v[space]google.com[space]80&rsquo;)
OS: linux_x86
Encode: none
Length: 74</p>

<p>shellcode.c:     file format elf32-i386</p>

<p>Disassembly of section .text:
00000000 &lt;.text>:
   0:   6a 0b                   push   $0xb
   2:   58                      pop    %eax
   3:   99                      cltd <br/>
   4:   52                      push   %edx
   5:   68 90 20 38 30          push   $0x30382090
   a:   59                      pop    %ecx
   b:   c1 e9 08                shr    $0x8,%ecx
   e:   51                      push   %ecx
   f:   68 2e 63 6f 6d          push   $0x6d6f632e
  14:   68 6f 67 6c 65          push   $0x656c676f
  19:   68 76 20 67 6f          push   $0x6f672076
  1e:   68 6e 63 20 2d          push   $0x2d20636e
  23:   89 e6                   mov    %esp,%esi
  25:   52                      push   %edx
  26:   68 90 90 2d 63          push   $0x632d9090
  2b:   59                      pop    %ecx
  2c:   c1 e9 10                shr    $0x10,%ecx
  2f:   51                      push   %ecx
  30:   89 e1                   mov    %esp,%ecx
  32:   52                      push   %edx
  33:   6a 68                   push   $0x68
  35:   68 2f 62 61 73          push   $0x7361622f
  3a:   68 2f 62 69 6e          push   $0x6e69622f
  3f:   89 e3                   mov    %esp,%ebx
  41:   52                      push   %edx
  42:   57                      push   %edi
  43:   56                      push   %esi
  44:   51                      push   %ecx
  45:   53                      push   %ebx
  46:   89 e1                   mov    %esp,%ecx
  48:   cd 80                   int    $0x80</p>

<p>compile example: gcc -ggdb -static -fno-stack-protector -z execstack -mpreferred-stack-boundary=2 -o shellcode_compiled shellcode.c
*/</p>

<p>int main(){
unsigned char shellcode[]= &ldquo;\x6a\x0b\x58\x99\x52\x68\x90\x20\x38\x30\x59\xc1\xe9\x08\x51\x68\x2e\x63\x6f\x6d\x68\x6f\x67\x6c\x65\x68\x76\x20\x67\x6f\x68\x6e\x63\x20\x2d\x89\xe6\x52\x68\x90\x90\x2d\x63\x59\xc1\xe9\x10\x51\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x57\x56\x51\x53\x89\xe1\xcd\x80&rdquo;;
fprintf(stdout,&ldquo;Length: %d\n\n&rdquo;,strlen(shellcode));
    (<em>(void(</em>)()) shellcode)();
}
<code>
Our shellcode built for &lt;strong&gt;linux_x86&lt;/strong&gt; OS that will execute "&lt;strong&gt;nc -v google.com 80&lt;/strong&gt;" command, And as we can see, we have disassembled code in the comment of C file.&lt;br&gt;&lt;br&gt;
</code>asm
Disassembly of section .text:
00000000 &lt;.text>:
   0:    6a 0b                   push   $0xb
   2:    58                      pop    %eax
   3:    99                      cltd <br/>
   4:    52                      push   %edx
   5:    68 90 20 38 30          push   $0x30382090
   a:    59                      pop    %ecx
   b:    c1 e9 08                shr    $0x8,%ecx
   e:    51                      push   %ecx
   f:    68 2e 63 6f 6d          push   $0x6d6f632e
  14:    68 6f 67 6c 65          push   $0x656c676f
  19:    68 76 20 67 6f          push   $0x6f672076
  1e:    68 6e 63 20 2d          push   $0x2d20636e
  23:    89 e6                   mov    %esp,%esi
  25:    52                      push   %edx
  26:    68 90 90 2d 63          push   $0x632d9090
  2b:    59                      pop    %ecx
  2c:    c1 e9 10                shr    $0x10,%ecx
  2f:    51                      push   %ecx
  30:    89 e1                   mov    %esp,%ecx
  32:    52                      push   %edx
  33:    6a 68                   push   $0x68
  35:    68 2f 62 61 73          push   $0x7361622f
  3a:    68 2f 62 69 6e          push   $0x6e69622f
  3f:    89 e3                   mov    %esp,%ebx
  41:    52                      push   %edx
  42:    57                      push   %edi
  43:    56                      push   %esi
  44:    51                      push   %ecx
  45:    53                      push   %ebx
  46:    89 e1                   mov    %esp,%ecx
  48:    cd 80                   int    $0x80
<code>
And now all we need is spliting the compiled assembly &lt;strong&gt;opcodes&lt;/strong&gt;.
</code>asm
push   $0xb
pop    %eax
cltd
push   %edx
push   $0x30382090
pop    %ecx
shr    $0x8,%ecx
push   %ecx
push   $0x6d6f632e
push   $0x656c676f
push   $0x6f672076
push   $0x2d20636e
mov    %esp,%esi
push   %edx
push   $0x632d9090
pop    %ecx
shr    $0x10,%ecx
push   %ecx
mov    %esp,%ecx
push   %edx
push   $0x68
push   $0x7361622f
push   $0x6e69622f
mov    %esp,%ebx
push   %edx
push   %edi
push   %esi
push   %ecx
push   %ebx
mov    %esp,%ecx
int    $0x80
<code>
&lt;br&gt;We have to save these codes inside a file and compile it. Then we have the PE file.
</code>asm
root@airz:/# cat shellcode.asm
push   $0xb
pop    %eax
cltd
push   %edx
push   $0x30382090
pop    %ecx
shr    $0x8,%ecx
push   %ecx
push   $0x6d6f632e
push   $0x656c676f
push   $0x6f672076
push   $0x2d20636e
mov    %esp,%esi
push   %edx
push   $0x632d9090
pop    %ecx
shr    $0x10,%ecx
push   %ecx
mov    %esp,%ecx
push   %edx
push   $0x68
push   $0x7361622f
push   $0x6e69622f
mov    %esp,%ebx
push   %edx
push   %edi
push   %esi
push   %ecx
push   %ebx
mov    %esp,%ecx
int    $0x80</p>

<p>root@airz:/# as shellcode.asm -o shellcode.o
root@airz:/# ld shellcode.o -o shellcode
ld: warning: cannot find entry symbol _start; defaulting to 0000000008048054
root@airz:/# ./shellcode
DNS fwd/rev mismatch: google.com != lga15s46-in-f7.1e100.net
DNS fwd/rev mismatch: google.com != lga15s46-in-f5.1e100.net
DNS fwd/rev mismatch: google.com != lga15s46-in-f8.1e100.net
DNS fwd/rev mismatch: google.com != lga15s46-in-f0.1e100.net
DNS fwd/rev mismatch: google.com != lga15s46-in-f9.1e100.net
DNS fwd/rev mismatch: google.com != lga15s46-in-f1.1e100.net
DNS fwd/rev mismatch: google.com != lga15s46-in-f4.1e100.net
DNS fwd/rev mismatch: google.com != lga15s46-in-f2.1e100.net
google.com [173.194.123.7] 80 (http) open
```
<br><h3>References</h3>
<a href="http://wwww.z3r0d4y.com">ZeroDay Cyber Research</a>
<br><a href="http://zsc.z3r0d4y.com">ZSC Home</a>
<br><a href="mailto:Ali[at]Z3r0D4y.Com">Ali Razmjoo</a>
<br><br><br><br></p>
]]></content>
  </entry>
  
</feed>
